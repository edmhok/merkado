{"version":3,"file":"static/js/1879.d923adc9.chunk.js","mappings":"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","sources":["hooks/swap/v2/index.ts","hooks/swap/v2/usePools.ts","hooks/swap/v2/useSwapCalls.ts","constants/v2.ts","store/swapv2/liquidity/hooks.ts","utils/swap/getTickToPrice.ts","utils/swap/maxAmountSpend.ts","utils/swap/mint.ts"],"sourcesContent":["import { useMemo, useCallback, useEffect, useState } from \"react\";\nimport { parseTokenAmount, formatTokenAmount, numberToString } from \"@w2e/utils\";\nimport { type NumberType } from \"@w2e/types\";\nimport { getTokenStandard, useUpdateTokenStandard } from \"store/token/cache/hooks\";\nimport { getPoolTokenStandard, getPoolCanisterId } from \"hooks/swap/v2/useSwapCalls\";\nimport { FeeAmount, Token } from \"@w2e/swap-sdk\";\n\nexport function useActualSwapAmount(amount: NumberType | undefined, currency: Token | undefined): string | undefined {\n  return useMemo(() => {\n    if (!amount || !currency) return undefined;\n\n    const typedValue = formatTokenAmount(amount, currency.decimals);\n    const fee = currency.transFee;\n\n    if (typedValue.isGreaterThan(currency.transFee)) {\n      return numberToString(parseTokenAmount(typedValue.minus(fee), currency.decimals));\n    }\n    return \"0\";\n  }, [amount, currency]);\n}\n\nexport function useUpdatePoolTokenStandardCallback() {\n  const updateTokenStandard = useUpdateTokenStandard();\n\n  return useCallback(async (poolId: string, tokenId: string) => {\n    if (!getTokenStandard(tokenId)) {\n      const standard = await getPoolTokenStandard(poolId, tokenId);\n      updateTokenStandard({ canisterId: tokenId, standard });\n    }\n  }, []);\n}\n\nexport function usePoolCanisterId(\n  token0CanisterId: string | undefined | null,\n  token1CanisterId: string | undefined | null,\n  fee: FeeAmount | undefined | null,\n) {\n  const poolKey = useMemo(() => {\n    return token0CanisterId && token1CanisterId && fee\n      ? `${token0CanisterId}_${token1CanisterId}_${String(fee)}`\n      : undefined;\n  }, [token0CanisterId, token1CanisterId, fee]);\n\n  const [poolCanisterId, stePoolCanisterId] = useState(\"\");\n\n  useEffect(() => {\n    const call = async () => {\n      if (token0CanisterId && token1CanisterId && fee && poolKey && !poolCanisterId) {\n        const poolCanisterId = await getPoolCanisterId(token0CanisterId, token1CanisterId, fee);\n        stePoolCanisterId(poolCanisterId);\n      }\n    };\n\n    call();\n  }, [poolCanisterId, token0CanisterId, token1CanisterId, fee, poolKey]);\n\n  return useMemo(() => poolCanisterId, [poolCanisterId]);\n}\n","import { Pool, Token, FeeAmount } from \"@w2e/swap-sdk\";\nimport { numberToString } from \"@w2e/utils\";\nimport { useMemo, useEffect, useState } from \"react\";\nimport { swapFactory, swapFactoryV1, swapPool } from \"actor/swapV2\";\nimport { SwapPoolInfo, TickLiquidityInfo } from \"types/swapv2\";\n\nexport enum PoolState {\n  LOADING = \"LOADING\",\n  NOT_EXISTS = \"NOT_EXISTS\",\n  EXISTS = \"EXISTS\",\n  INVALID = \"INVALID\",\n}\n\ntype TypePoolsState = {\n  address: string;\n  info: SwapPoolInfo | null;\n  ticks: TickLiquidityInfo[];\n};\n\nexport function usePools(\n  poolKeys: [Token | undefined, Token | undefined, FeeAmount | undefined][],\n  version?: \"v2\" | \"v1\",\n): [PoolState, Pool | null][] {\n  const [pools, setPools] = useState<TypePoolsState[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const transformedPoolKeys = useMemo(() => {\n    return poolKeys.map(([currencyA, currencyB, feeAmount]) => {\n      if (!currencyA || !currencyB || !feeAmount) return null;\n\n      const tokenA = currencyA?.wrapped;\n      const tokenB = currencyB?.wrapped;\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return null;\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n\n      return `${token0.address}_${token1.address}_${feeAmount}`;\n    });\n  }, [poolKeys]);\n\n  useEffect(() => {\n    if (transformedPoolKeys && transformedPoolKeys.length && !transformedPoolKeys.includes(null)) {\n      setLoading(true);\n\n      Promise.all<TypePoolsState | undefined>(\n        transformedPoolKeys.map(async (key) => {\n          if (!key) return undefined;\n\n          let poolAddress = \"\";\n\n          if (version === \"v1\") {\n            poolAddress = (await (await swapFactoryV1()).getPool(key)) as string;\n          } else {\n            poolAddress = (await (await swapFactory()).getPool(key)) as string;\n          }\n\n          let poolInfo: SwapPoolInfo | null = null;\n          const ticks: TickLiquidityInfo[] = [];\n\n          if (poolAddress) {\n            poolInfo = await (await swapPool(poolAddress)).infoWithNoBalance();\n          }\n\n          return {\n            address: poolAddress,\n            info: poolInfo,\n            ticks,\n          };\n        }),\n      ).then((result) => {\n        setPools(result.filter((e) => !!e) as TypePoolsState[]);\n        setLoading(false);\n      });\n    }\n  }, [transformedPoolKeys]);\n\n  return useMemo(() => {\n    return transformedPoolKeys.map((poolKey, index) => {\n      if (!poolKey) return [PoolState.INVALID, null];\n      if (loading) return [PoolState.LOADING, null];\n\n      const _pool: TypePoolsState | undefined = pools[index];\n      const { info: pool, address: poolAddress } = _pool ?? ({} as TypePoolsState);\n\n      if (!pool || !pool?.token0 || !pool?.token1 || !pool?.fee) return [PoolState.NOT_EXISTS, null];\n\n      try {\n        const { fee, sqrtRatioX96, liquidity, tickCurrent } = pool;\n        const [token0, token1] = poolKeys[index];\n\n        if (!token0 || !token1) return [PoolState.NOT_EXISTS, null];\n\n        return [\n          PoolState.EXISTS,\n          new Pool(\n            poolAddress,\n            token0.wrapped,\n            token1.wrapped,\n            Number(fee),\n            numberToString(sqrtRatioX96),\n            numberToString(liquidity),\n            Number(tickCurrent),\n          ),\n        ];\n      } catch (error) {\n        console.error(\"Error when constructing the pool\", error);\n        return [PoolState.NOT_EXISTS, null];\n      }\n    });\n  }, [pools, loading, poolKeys, transformedPoolKeys]);\n}\n\nexport function usePool(currencyA: Token | undefined, currencyB: Token | undefined, feeAmount: FeeAmount | undefined) {\n  const poolKeys: [Token | undefined, Token | undefined, FeeAmount | undefined][] = useMemo(\n    () => [[currencyA, currencyB, feeAmount]],\n    [currencyA, currencyB, feeAmount],\n  );\n\n  return usePools(poolKeys)[0];\n}\n\nexport function usePoolV1(\n  currencyA: Token | undefined,\n  currencyB: Token | undefined,\n  feeAmount: FeeAmount | undefined,\n) {\n  const poolKeys: [Token | undefined, Token | undefined, FeeAmount | undefined][] = useMemo(\n    () => [[currencyA, currencyB, feeAmount]],\n    [currencyA, currencyB, feeAmount],\n  );\n\n  return usePools(poolKeys, \"v1\")[0];\n}\n","import { useCallback, useEffect, useMemo, useState } from \"react\";\nimport {\n  swapPositionManager,\n  swapPositionManagerV1,\n  swapFactory,\n  swapRouter,\n  swapRecord,\n  swapPool,\n  swapGraphPool,\n} from \"actor/swapV2\";\nimport { resultFormat, isAvailablePageArgs } from \"@w2e/utils\";\nimport { useCallsData } from \"@w2e/hooks\";\nimport { FeeAmount } from \"@w2e/swap-sdk\";\nimport { useStateCallsData } from \"hooks/useCallsData\";\nimport { useAccount } from \"store/global/hooks\";\nimport {\n  PoolInfo,\n  PositionResult,\n  IncreaseLiquidityParams,\n  DecreaseLiquidityParams,\n  IncreaseLiquidityResult,\n  DecreaseLiquidityResult,\n  PoolKey,\n  TVLResult,\n  MintResult,\n  TickLiquidityInfo,\n  SwapRecordInfo,\n  CollectResult,\n  CollectParams,\n  VolumeResult,\n  SwapPoolRecord,\n  QueryPositionResult,\n} from \"types/swapv2\";\nimport { Identity, PaginationResult } from \"types/global\";\nimport { Principal } from \"@dfinity/principal\";\nimport { TOKEN_STANDARD } from \"constants/tokens\";\n\nexport async function getPoolList(): Promise<PoolInfo[]> {\n  return await (await swapFactory()).getPoolList();\n}\n\nexport async function getPoolIds(): Promise<string[]> {\n  return await (await swapFactory()).getPoolIds();\n}\n\nexport async function getPoolTokenStandard(poolId: string, tokenId: string): Promise<TOKEN_STANDARD> {\n  return (await (await swapPool(poolId)).getStandard(tokenId)) as TOKEN_STANDARD;\n}\n\nexport async function getPoolInfoWithNoBalance(poolId: string): Promise<PoolInfo> {\n  return await (await swapPool(poolId)).infoWithNoBalance();\n}\n\nexport function usePoolIds() {\n  const call = useCallback(async () => {\n    return (await getPoolIds()) as string[];\n  }, []);\n\n  return useStateCallsData(call, \"usePoolIds\", true, false, true);\n}\n\nexport function usePoolList() {\n  const { result: poolIds, loading: poolIdsLoading } = usePoolIds();\n\n  const [pools, setPools] = useState<PoolInfo[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const pools: PoolInfo[] = [];\n    let errorNum = 0;\n\n    function trigger() {\n      if (poolIds && pools.length === poolIds.length - errorNum) {\n        setPools(pools);\n        setLoading(false);\n      }\n    }\n\n    const fetch = async (poolId: string) => {\n      const pool = await getPoolInfoWithNoBalance(poolId).catch((err) => {\n        console.error(err);\n        return null;\n      });\n\n      if (!pool) {\n        errorNum++;\n      } else {\n        pools.push(pool);\n      }\n\n      trigger();\n    };\n\n    if (poolIds && poolIds.length > 0) {\n      setLoading(true);\n      for (let i = 0; i < poolIds.length; i++) {\n        fetch(poolIds[i]);\n      }\n    }\n  }, [poolIds]);\n\n  return useMemo(() => ({ loading: poolIdsLoading || loading, pools }), [loading, pools]);\n}\n\nexport function usePosition(positionId: string | number | bigint, invalid?: boolean) {\n  return useCallsData(\n    useCallback(async () => {\n      let result: QueryPositionResult | undefined;\n\n      if (invalid) {\n        result = resultFormat<PositionResult>(\n          await (await swapPositionManager()).invalidPositions(BigInt(positionId)),\n        ).data;\n      } else {\n        result = resultFormat<PositionResult>(await (await swapPositionManager()).positions(BigInt(positionId))).data;\n      }\n\n      return result;\n    }, [positionId]),\n  );\n}\n\nexport async function increaseLiquidity(identity: Identity, params: IncreaseLiquidityParams) {\n  return resultFormat<IncreaseLiquidityResult>(await (await swapPositionManager(identity)).increaseLiquidity(params));\n}\n\nexport async function decreaseLiquidity(identity: Identity, params: DecreaseLiquidityParams) {\n  return resultFormat<DecreaseLiquidityResult>(await (await swapPositionManager(identity)).decreaseLiquidity(params));\n}\n\nexport function useQuoteExactInput(args: string | undefined) {\n  const call = useCallback(async () => {\n    if (!args) return undefined;\n    const { path, amountIn } = JSON.parse(args) as { path: string; amountIn: string };\n    return resultFormat<bigint>(await (await swapRouter()).quoteExactInput(path, amountIn)).data;\n  }, [args]);\n\n  return useStateCallsData(call, \"quoteExactInputV2\", !!args);\n}\n\nexport function useQuoteUnitPrice(path: string | undefined, amountIn: string | number | undefined) {\n  return useCallsData(\n    useCallback(async () => {\n      if (!path || !amountIn || amountIn === \"0\") return undefined;\n      return resultFormat<bigint>(await (await swapRouter()).getUnitPrice(path, String(amountIn))).data;\n    }, [path, amountIn]),\n  );\n}\n\nexport function useQuoteExactOutput(path: string | undefined, amountOut: string | undefined) {\n  const call = useCallback(async () => {\n    if (!path || !amountOut || amountOut === \"0\") return undefined;\n    return resultFormat<bigint>(await (await swapRouter()).quoteExactOutput(path, String(amountOut))).data;\n  }, [path, amountOut]);\n\n  return useStateCallsData(call, \"quoteExactOutputV2\", !!path && !!amountOut);\n}\n\nexport async function exactInputSingle(\n  identity: Identity,\n  path: string,\n  recipient: Principal,\n  deadline: bigint | number,\n  amountIn: string,\n  amountOutMinimum: string,\n) {\n  return resultFormat<bigint>(\n    await (await swapRouter(identity)).exactInput(path, recipient, BigInt(deadline), amountIn, amountOutMinimum),\n  );\n}\n\nexport async function exactOutputSingle(\n  identity: Identity,\n  path: string,\n  recipient: Principal,\n  deadline: bigint | number,\n  amountOut: string,\n  amountInMinimum: string,\n) {\n  return resultFormat<bigint>(\n    await (await swapRouter(identity)).exactOutput(path, recipient, BigInt(deadline), amountOut, amountInMinimum),\n  );\n}\n\nexport function useFeeAmount(feeAmountKeys: (PoolKey | null)[]) {\n  return useCallsData(\n    useCallback(async () => {\n      if (!feeAmountKeys || feeAmountKeys.length === 0 || feeAmountKeys.includes(null)) return undefined;\n      return resultFormat<TVLResult[]>(await (await swapPositionManager()).getPoolTVL(feeAmountKeys as PoolKey[])).data;\n    }, [feeAmountKeys]),\n  );\n}\n\nexport async function mint(\n  identity: Identity,\n  token0: string,\n  token1: string,\n  fee: bigint,\n  tickLower: bigint,\n  tickUpper: bigint,\n  amount0Desired: string,\n  amount1Desired: string,\n  amount0Min: string,\n  amount1Min: string,\n  recipient: Principal,\n  deadline: bigint,\n) {\n  return resultFormat<MintResult>(\n    await (\n      await swapPositionManager(identity)\n    ).mint({\n      token0,\n      token1,\n      fee,\n      tickLower,\n      tickUpper,\n      amount0Desired,\n      amount1Desired,\n      amount0Min,\n      amount1Min,\n      recipient,\n      deadline,\n    }),\n  );\n}\n\nexport function useUserTokens() {\n  const account = useAccount();\n\n  return useCallsData(\n    useCallback(async () => {\n      if (!account) return [];\n      return resultFormat<bigint[]>(await (await swapPositionManager()).ownerTokens(account)).data;\n    }, [account]),\n  );\n}\n\nexport function useUserV1Tokens() {\n  const account = useAccount();\n\n  return useCallsData(\n    useCallback(async () => {\n      if (!account) return [];\n      return resultFormat<bigint[]>(await (await swapPositionManagerV1()).ownerTokens(account)).data;\n    }, [account]),\n  );\n}\n\nexport function useUserInvalidTokens() {\n  const account = useAccount();\n\n  return useCallsData(\n    useCallback(async () => {\n      return resultFormat<bigint[]>(await (await swapPositionManager()).ownerInvalidTokens(account)).data;\n    }, [account]),\n  );\n}\n\nexport async function getPoolCanisterId(token0CanisterId: string, token1CanisterId: string, fee: FeeAmount) {\n  return await (await swapFactory()).getPool(`${token0CanisterId}_${token1CanisterId}_${String(fee)}`);\n}\n\nexport function usePoolCanisterId(\n  token0CanisterId: string | undefined | null,\n  token1CanisterId: string | undefined | null,\n  fee: FeeAmount | undefined | null,\n) {\n  return useCallsData(\n    useCallback(async () => {\n      if (!token0CanisterId || !token1CanisterId || !fee) return undefined;\n      return resultFormat<string>(await getPoolCanisterId(token0CanisterId, token1CanisterId, fee)).data;\n    }, [token0CanisterId, token1CanisterId, fee]),\n  );\n}\n\nexport function useLiquidityTicks(poolId: string | undefined | null) {\n  return useCallsData(\n    useCallback(async () => {\n      if (!poolId) return undefined;\n      return resultFormat<TickLiquidityInfo[]>(await (await swapPool(poolId)).getTickInfos()).data;\n    }, [poolId]),\n  );\n}\n\nexport function useSwapRecord(account: string, offset: number, limit: number) {\n  return useCallsData(\n    useCallback(async () => {\n      if (!account || !isAvailablePageArgs(offset, limit)) return undefined;\n      return resultFormat<PaginationResult<SwapRecordInfo>>(\n        await (await swapRecord()).get(account, BigInt(offset), BigInt(limit)),\n      ).data;\n    }, [account, offset, limit]),\n  );\n}\n\nexport function useCollectFeesCall(invalid: boolean) {\n  return useCallback(\n    async (identity: Identity, params: CollectParams) => {\n      if (invalid) {\n        return resultFormat<CollectResult>(\n          await (await swapPositionManager(identity)).collectInInvalidPosition(params),\n        );\n      }\n\n      return resultFormat<CollectResult>(await (await swapPositionManager(identity)).collect(params));\n    },\n    [invalid],\n  );\n}\n\nexport function usePoolTotalVolumeCall(poolKey: string | undefined) {\n  return useCallsData(\n    useCallback(async () => {\n      if (!poolKey) return undefined;\n      return resultFormat<VolumeResult>(await (await swapPositionManager()).getTotalVolume(poolKey)).data;\n    }, [poolKey]),\n  );\n}\n\nexport function usePositionFeesCall(\n  positionId: bigint | string | number | undefined,\n  invalid: boolean,\n  reload?: boolean,\n) {\n  return useCallsData(\n    useCallback(async () => {\n      if (!positionId) return undefined;\n\n      let result: { amount0: bigint; amount1: bigint } | undefined;\n\n      if (invalid) {\n        result = resultFormat<CollectResult>(\n          await (await swapPositionManager()).refreshInvalidIncome(BigInt(positionId)),\n        ).data;\n      } else {\n        result = resultFormat<CollectResult>(\n          await (await swapPositionManager()).refreshIncome(BigInt(positionId)),\n        ).data;\n      }\n\n      return result;\n    }, [positionId, invalid]),\n    reload,\n  );\n}\n\nexport async function getV2SwapNFTTokenURI(tokenId: bigint | number) {\n  const result = resultFormat<string>(await (await swapPositionManager()).tokenURI(BigInt(tokenId))).data;\n  const data = JSON.parse(result ?? '\"\"') as { image: string } | \"\";\n\n  return data ? data.image : \"\";\n}\n\nexport function useFourListedPools() {\n  return useCallsData(\n    useCallback(async () => {\n      return resultFormat<SwapPoolRecord[]>(await (await swapGraphPool()).getAllPools([])).data;\n    }, []),\n  );\n}\n\nexport async function decreaseInvalidLiquidity(identity: Identity, params: DecreaseLiquidityParams) {\n  return resultFormat<DecreaseLiquidityResult>(\n    await (await swapPositionManager(identity)).decreaseLiquidityInInvalidPosition(params),\n  );\n}\n\nexport async function decreaseV1Liquidity(identity: Identity, params: DecreaseLiquidityParams) {\n  return resultFormat<DecreaseLiquidityResult>(await (await swapPositionManagerV1(identity)).decreaseLiquidity(params));\n}\n","export const DISABLE_ADD_LIQUIDITY_IDS = [\n  \"ew2hr-oaaaa-aaaan-qcycq-cai\",\n  \"m4mib-siaaa-aaaan-qaucq-cai\",\n  \"4ch4l-viaaa-aaaan-qa3bq-cai\",\n  \"uldch-7yaaa-aaaan-qa2wq-cai\",\n  \"2d2yc-biaaa-aaaan-qa4ka-cai\",\n];\n\nexport const DISABLE_SWAP_IDS = [\n  \"ew2hr-oaaaa-aaaan-qcycq-cai\",\n  \"m4mib-siaaa-aaaan-qaucq-cai\",\n  \"4ch4l-viaaa-aaaan-qa3bq-cai\",\n  \"uldch-7yaaa-aaaan-qa2wq-cai\",\n  \"2d2yc-biaaa-aaaan-qa4ka-cai\",\n];\n","/* eslint-disable no-inner-declarations */\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useAppSelector, useAppDispatch } from \"store/hooks\";\nimport { Bound, BIG_INT_ZERO, FIELD } from \"constants/swap\";\nimport { resultFormat } from \"@w2e/utils\";\nimport {\n  FeeAmount,\n  TickMath,\n  tickToPrice,\n  TICK_SPACINGS,\n  priceToClosestTick,\n  encodeSqrtRatioX96,\n  Pool,\n  Position,\n  Token,\n  Rounding,\n  Price,\n  CurrencyAmount,\n  nearestUsableTick,\n} from \"@w2e/swap-sdk\";\nimport { tryParseTick } from \"utils/swap/mint\";\nimport { tryParseAmount } from \"utils/swap\";\nimport { getTickToPrice } from \"utils/swap/getTickToPrice\";\nimport { usePool, PoolState } from \"hooks/swap/v2/usePools\";\nimport { JSBI } from \"utils/index\";\nimport { useUserTokens, useUserV1Tokens, useUserInvalidTokens } from \"hooks/swap/v2/useSwapCalls\";\nimport { swapPositionManager, swapFactory, swapPositionManagerV1, swapFactoryV1 } from \"actor/swapV2\";\nimport { useCurrencyBalance } from \"hooks/token/useTokenBalance\";\nimport { maxAmountSpend } from \"utils/swap/maxAmountSpend\";\nimport { t } from \"@lingui/macro\";\nimport { PositionResult, UserPosition } from \"types/swapv2\";\nimport { useAccountPrincipal } from \"store/auth/hooks\";\nimport { useUpdatePoolTokenStandardCallback } from \"hooks/swap/v2/index\";\nimport { DISABLE_ADD_LIQUIDITY_IDS } from \"constants/v2\";\nimport {\n  updateUserPositions,\n  updateFiled,\n  updateLeftRange,\n  updateRightRange,\n  updateStartPrice,\n  updateFullRange,\n  resetMintState,\n} from \"./actions\";\n\nexport function useUserV1Positions() {\n  const [loading, setLoading] = useState(true);\n  const updateTokenStandard = useUpdatePoolTokenStandardCallback();\n  const { result: tokenIds } = useUserV1Tokens();\n\n  const [positions, setPositions] = useState<(UserPosition | undefined)[]>([]);\n\n  useEffect(() => {\n    setLoading(true);\n\n    if (tokenIds && tokenIds.length > 0) {\n      const positions: (PositionResult | undefined)[] = [];\n      let done = 0;\n\n      // @ts-ignore\n      function trigger() {\n        if (done === tokenIds?.length) {\n          const positionsWithTokenIds: (UserPosition | undefined)[] = [];\n\n          positions.forEach((position, index) => {\n            if (position) {\n              positionsWithTokenIds.push({\n                ...position,\n                id: tokenIds[index],\n              });\n            }\n          });\n\n          setPositions(positionsWithTokenIds);\n\n          setLoading(false);\n        }\n      }\n\n      tokenIds.forEach(async (tokenId, index) => {\n        (await swapPositionManagerV1())\n          .positions(tokenId)\n          .then(async (result: any) => {\n            const pool = resultFormat<PositionResult>(result).data;\n            if (pool) {\n              const poolId = await (\n                await swapFactoryV1()\n              ).getPool(`${pool?.token0}_${pool?.token1}_${String(pool?.fee)}`);\n              await updateTokenStandard(poolId, pool.token0);\n              await updateTokenStandard(poolId, pool.token1);\n            }\n            positions[index] = pool;\n            done++;\n            trigger();\n          })\n          .catch((err: Error) => {\n            done++;\n            trigger();\n            positions[index] = undefined;\n            console.error(err);\n          });\n      });\n    } else {\n      setLoading(false);\n      setPositions([]);\n    }\n  }, [tokenIds, setLoading]);\n\n  return useMemo(\n    () => ({\n      loading,\n      result: positions,\n    }),\n    [loading, positions],\n  );\n}\n\nexport function useQueryUserPositions() {\n  const dispatch = useAppDispatch();\n  const [loading, setLoading] = useState(true);\n  const updateTokenStandard = useUpdatePoolTokenStandardCallback();\n  const { result: tokenIds } = useUserTokens();\n\n  useEffect(() => {\n    setLoading(true);\n\n    if (tokenIds && tokenIds.length > 0) {\n      const positions: (PositionResult | undefined)[] = [];\n      let done = 0;\n\n      // @ts-ignore\n      function trigger() {\n        if (done === tokenIds?.length) {\n          const positionsWithTokenIds: (UserPosition | undefined)[] = [];\n\n          positions.forEach((position, index) => {\n            if (position) {\n              positionsWithTokenIds.push({\n                ...position,\n                id: tokenIds[index],\n              });\n            }\n          });\n\n          dispatch(updateUserPositions(positionsWithTokenIds));\n          setLoading(false);\n        }\n      }\n\n      tokenIds.forEach(async (tokenId, index) => {\n        (await swapPositionManager())\n          .positions(tokenId)\n          .then(async (result: any) => {\n            const pool = resultFormat<PositionResult>(result).data;\n\n            if (pool) {\n              const poolId = await (\n                await swapFactory()\n              ).getPool(`${pool?.token0}_${pool?.token1}_${String(pool?.fee)}`);\n\n              await updateTokenStandard(poolId, pool.token0);\n              await updateTokenStandard(poolId, pool.token1);\n            }\n\n            positions[index] = pool;\n            done++;\n            trigger();\n          })\n          .catch((err: Error) => {\n            done++;\n            trigger();\n            positions[index] = undefined;\n            console.error(err);\n          });\n      });\n    } else {\n      setLoading(false);\n      dispatch(updateUserPositions([]));\n    }\n  }, [dispatch, tokenIds, setLoading]);\n\n  return loading;\n}\n\nexport function useUserInvalidPositions() {\n  const [positions, setPositions] = useState<(UserPosition | undefined)[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const { result: tokenIds, loading: loading1 } = useUserInvalidTokens();\n\n  useEffect(() => {\n    if (tokenIds?.length) {\n      setLoading(true);\n\n      const positions: (PositionResult | undefined)[] = [];\n      let done = 0;\n\n      // @ts-ignore\n      function trigger() {\n        if (done === tokenIds?.length) {\n          const positionsWithTokenIds: (UserPosition | undefined)[] = [];\n\n          positions.forEach((position, index) => {\n            if (position) {\n              positionsWithTokenIds.push({\n                ...position,\n                id: tokenIds[index],\n              });\n            }\n          });\n\n          setPositions(positionsWithTokenIds);\n\n          setLoading(false);\n        }\n      }\n\n      tokenIds.forEach(async (tokenId, index) => {\n        (await swapPositionManager())\n          .invalidPositions(tokenId)\n          .then((result: any) => {\n            positions[index] = resultFormat<PositionResult>(result).data;\n            done++;\n            trigger();\n          })\n          .catch((err: Error) => {\n            done++;\n            trigger();\n            positions[index] = undefined;\n            console.error(err);\n          });\n      });\n    }\n  }, [tokenIds]);\n\n  return useMemo(\n    () => ({\n      loading: loading || loading1,\n      positions,\n    }),\n    [loading, loading1, positions],\n  );\n}\n\nexport function useUserPositions() {\n  return useAppSelector((state) => state.swapV2Liquidity.userPositions);\n}\n\nexport function useMintState() {\n  return useAppSelector((state) => state.swapV2Liquidity);\n}\n\nexport function useResetMintState() {\n  const dispatch = useAppDispatch();\n  return useCallback(() => {\n    dispatch(resetMintState());\n  }, [dispatch]);\n}\n\nexport function useMintInfo(\n  currencyA: Token | undefined,\n  currencyB: Token | undefined,\n  feeAmount: FeeAmount | undefined,\n  baseCurrency: Token | undefined,\n  existingPosition?: Position,\n  inverted?: boolean | undefined,\n) {\n  const {\n    independentField,\n    typedValue,\n    leftRangeValue: leftRangeTypedValue,\n    rightRangeValue: rightRangeTypedValue,\n    startPrice,\n  } = useMintState();\n\n  const dependentField = independentField === FIELD.CURRENCY_A ? FIELD.CURRENCY_B : FIELD.CURRENCY_A;\n\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency],\n  );\n\n  const currencies = useMemo(\n    () => ({\n      [FIELD.CURRENCY_A]: currencyA,\n      [FIELD.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB],\n  );\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB],\n  );\n\n  const principal = useAccountPrincipal();\n  const { result: tokenABalance } = useCurrencyBalance(principal, tokenA);\n  const { result: tokenBBalance } = useCurrencyBalance(principal, tokenB);\n\n  const currencyBalances = {\n    [FIELD.CURRENCY_A]: tokenABalance,\n    [FIELD.CURRENCY_B]: tokenBBalance,\n  };\n\n  const [poolState, pool] = usePool(currencies[FIELD.CURRENCY_A], currencies[FIELD.CURRENCY_B], feeAmount);\n\n  const noLiquidity = poolState === PoolState.NOT_EXISTS;\n  const poolLoading = poolState === PoolState.LOADING;\n\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0));\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseAmount(startPrice || \"0.1\", invertPrice ? token0 : token1);\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseAmount(\"1\", invertPrice ? token1 : token0);\n\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient,\n              )\n            : undefined;\n\n        return (invertPrice ? price?.invert() : price) ?? undefined;\n      }\n      return undefined;\n    }\n    // get the amount of quote currency\n    return pool && token0 ? pool.priceOf(token0) : undefined;\n  }, [noLiquidity, startPrice, invertPrice, token1, token0, pool]);\n\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined;\n    const invalid =\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      );\n    return invalid;\n  }, [price]);\n\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price);\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick);\n\n      return new Pool(\"\", tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, []);\n    }\n    return undefined;\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB]);\n\n  const poolForPosition = pool ?? mockPool;\n\n  const tickSpaceLimits = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount],\n  );\n\n  const ticks = useMemo(() => {\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === \"number\"\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === \"boolean\") ||\n            (!invertPrice && typeof leftRangeTypedValue === \"boolean\")\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === \"number\"\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === \"boolean\") ||\n            (invertPrice && typeof leftRangeTypedValue === \"boolean\")\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    };\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n  ]);\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {};\n\n  const _ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount],\n  );\n\n  const ticksAtLimit = useMemo(() => {\n    if (!inverted) return _ticksAtLimit;\n\n    return {\n      [Bound.LOWER]: _ticksAtLimit[Bound.UPPER] ? true : undefined,\n      [Bound.UPPER]: _ticksAtLimit[Bound.LOWER] ? true : undefined,\n    };\n  }, [_ticksAtLimit, inverted]);\n\n  const invalidRange = Boolean(\n    typeof tickLower === \"number\" && typeof tickUpper === \"number\" && tickLower >= tickUpper,\n  );\n\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    };\n  }, [token0, token1, ticks]);\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks;\n\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice)),\n  );\n\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n\n  const dependentAmount = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped;\n    const dependentCurrency = dependentField === FIELD.CURRENCY_B ? currencyB : currencyA;\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === \"number\" &&\n      typeof tickUpper === \"number\" &&\n      poolForPosition\n    ) {\n      if (outOfRange || invalidRange) {\n        return undefined;\n      }\n\n      const position = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true,\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          });\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0;\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient);\n    }\n\n    return undefined;\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ]);\n\n  const parsedAmounts = useMemo(() => {\n    return {\n      [FIELD.CURRENCY_A]: independentField === FIELD.CURRENCY_A ? independentAmount : dependentAmount,\n      [FIELD.CURRENCY_B]: independentField === FIELD.CURRENCY_A ? dependentAmount : independentAmount,\n    };\n  }, [dependentAmount, independentAmount, independentField]);\n\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === \"number\" && poolForPosition && poolForPosition.tickCurrent >= tickUpper,\n  );\n\n  const deposit1Disabled = Boolean(\n    typeof tickLower === \"number\" && poolForPosition && poolForPosition.tickCurrent <= tickLower,\n  );\n\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA)),\n    );\n\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB)),\n    );\n\n  const position = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== \"number\" ||\n      typeof tickUpper !== \"number\" ||\n      invalidRange\n    ) {\n      return undefined;\n    }\n\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? FIELD.CURRENCY_A : FIELD.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO;\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? FIELD.CURRENCY_B : FIELD.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO;\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true, // we want full precision for the theoretical position\n      });\n    }\n    return undefined;\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ]);\n\n  const maxAmounts: { [field in FIELD]?: CurrencyAmount<Token> } = [FIELD.CURRENCY_A, FIELD.CURRENCY_B].reduce(\n    (accumulator, field) => {\n      return {\n        ...accumulator,\n        [field]: maxAmountSpend(currencyBalances[field]),\n      };\n    },\n    {},\n  );\n\n  const atMaxAmounts: { [field in FIELD]?: CurrencyAmount<Token> } = [FIELD.CURRENCY_A, FIELD.CURRENCY_B].reduce(\n    (accumulator, field) => {\n      return {\n        ...accumulator,\n        [field]: maxAmounts[field]?.equalTo(parsedAmounts[field] ?? \"0\"),\n      };\n    },\n    {},\n  );\n\n  let errorMessage: string | undefined;\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? t`Invalid pair`;\n  }\n\n  if (noLiquidity) {\n    errorMessage = t`Please add liquidity in ICPSwap V3`;\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? t`Invalid price input`;\n  }\n\n  if (invalidRange) {\n    errorMessage = errorMessage ?? t`Invalid Range`;\n  }\n\n  if (\n    (!parsedAmounts[FIELD.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[FIELD.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? t`Enter an amount`;\n  }\n\n  const { [FIELD.CURRENCY_A]: currencyAAmount, [FIELD.CURRENCY_B]: currencyBAmount } = parsedAmounts;\n\n  if (currencyAAmount && currencyBalances?.[FIELD.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    errorMessage = `Insufficient ${currencies[FIELD.CURRENCY_A]?.symbol} balance`;\n  }\n\n  if (currencyBAmount && currencyBalances?.[FIELD.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    errorMessage = `Insufficient ${currencies[FIELD.CURRENCY_B]?.symbol} balance`;\n  }\n\n  if (DISABLE_ADD_LIQUIDITY_IDS.includes(pool?.id ?? \"\")) {\n    errorMessage = t`Please add liquidity in ICPSwap V3`;\n  }\n\n  return {\n    ticks,\n    pricesAtTicks,\n    invalidRange,\n    outOfRange,\n    invalidPrice,\n    parsedAmounts,\n    dependentField,\n    depositADisabled,\n    depositBDisabled,\n    ticksAtLimit,\n    errorMessage,\n    position,\n    price,\n    invertPrice,\n    pool,\n    noLiquidity,\n    currencyBalances,\n    atMaxAmounts,\n    maxAmounts,\n    poolLoading,\n  };\n}\n\nexport function useMintHandlers(noLiquidity: boolean) {\n  const dispatch = useAppDispatch();\n\n  const onFieldAInput = useCallback(\n    (value: string) => {\n      dispatch(\n        updateFiled({\n          field: FIELD.CURRENCY_A,\n          typedValue: value,\n        }),\n      );\n    },\n    [dispatch, noLiquidity],\n  );\n\n  const onFieldBInput = useCallback(\n    (value: string) => {\n      dispatch(\n        updateFiled({\n          field: FIELD.CURRENCY_B,\n          typedValue: value,\n        }),\n      );\n    },\n    [dispatch, noLiquidity],\n  );\n\n  const onLeftRangeInput = useCallback(\n    (value) => {\n      dispatch(updateLeftRange(value));\n    },\n    [dispatch],\n  );\n\n  const onRightRangeInput = useCallback(\n    (value) => {\n      dispatch(updateRightRange(value));\n    },\n    [dispatch],\n  );\n\n  const onStartPriceInput = useCallback(\n    (value) => {\n      dispatch(updateStartPrice(value));\n    },\n    [dispatch],\n  );\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  };\n}\n\nexport function useRangeCallbacks(\n  baseCurrency: Token | undefined,\n  quoteCurrency: Token | undefined,\n  feeAmount: FeeAmount,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool: Pool | undefined | null,\n) {\n  const dispatch = useAppDispatch();\n\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency]);\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency]);\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(updateFullRange());\n  }, [dispatch]);\n\n  return {\n    getDecrementLower,\n    getIncrementLower,\n    getDecrementUpper,\n    getIncrementUpper,\n    getSetFullRange,\n  };\n}\n","import { Token, Price, tickToPrice } from \"@w2e/swap-sdk\";\n\nexport function getTickToPrice(baseToken?: Token, quoteToken?: Token, tick?: number): Price<Token, Token> | undefined {\n  if (!baseToken || !quoteToken || typeof tick !== \"number\") return undefined;\n  return tickToPrice(baseToken, quoteToken, tick);\n}\n","import { Token, CurrencyAmount } from \"@w2e/swap-sdk\";\n\n/**\n * Given some token amount, return the max that can be spent of it\n * @param currencyAmount to return max of\n */\nexport function maxAmountSpend(currencyAmount?: CurrencyAmount<Token>): CurrencyAmount<Token> | undefined {\n  if (!currencyAmount) return undefined;\n\n  const maxAmountSubFee = currencyAmount.subtract(\n    CurrencyAmount.fromRawAmount(currencyAmount.currency, currencyAmount.currency.transFee * 2),\n  );\n\n  return maxAmountSubFee;\n}\n","import {\n  Price,\n  Token,\n  priceToClosestTick,\n  nearestUsableTick,\n  FeeAmount,\n  TICK_SPACINGS,\n  encodeSqrtRatioX96,\n  TickMath,\n} from \"@w2e/swap-sdk\";\nimport JSBI from \"jsbi\";\n\nexport function tryParsePrice(baseToken?: Token, quoteToken?: Token, value?: string) {\n  if (!baseToken || !quoteToken || !value) {\n    return undefined;\n  }\n\n  if (!value.match(/^\\d*\\.?\\d+$/)) {\n    return undefined;\n  }\n\n  const [whole, fraction] = value.split(\".\");\n\n  const decimals = fraction?.length ?? 0;\n  const withoutDecimals = JSBI.BigInt((whole ?? \"\") + (fraction ?? \"\"));\n\n  return new Price(\n    baseToken,\n    quoteToken,\n    JSBI.multiply(JSBI.BigInt(10 ** decimals), JSBI.BigInt(10 ** baseToken.decimals)),\n    JSBI.multiply(withoutDecimals, JSBI.BigInt(10 ** quoteToken.decimals)),\n  );\n}\n\nexport function tryParseTick(\n  baseToken?: Token,\n  quoteToken?: Token,\n  feeAmount?: FeeAmount,\n  value?: string,\n): number | undefined {\n  if (!baseToken || !quoteToken || !feeAmount || !value) {\n    return undefined;\n  }\n\n  const price = tryParsePrice(baseToken, quoteToken, value);\n\n  if (!price) {\n    return undefined;\n  }\n\n  let tick: number;\n\n  // check price is within min/max bounds, if outside return min/max\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator);\n\n  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {\n    tick = TickMath.MAX_TICK;\n  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {\n    tick = TickMath.MIN_TICK;\n  } else {\n    // this function is agnostic to the base, will always return the correct tick\n    tick = priceToClosestTick(price);\n  }\n\n  return nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n}\n"],"names":["useUpdatePoolTokenStandardCallback","updateTokenStandard","useUpdateTokenStandard","useCallback","async","poolId","tokenId","getTokenStandard","standard","getPoolTokenStandard","canisterId","PoolState","usePools","poolKeys","version","pools","setPools","useState","loading","setLoading","transformedPoolKeys","useMemo","map","_ref","currencyA","currencyB","feeAmount","tokenA","wrapped","tokenB","equals","token0","token1","sortsBefore","concat","address","useEffect","length","includes","Promise","all","key","poolAddress","swapFactoryV1","getPool","swapFactory","poolInfo","swapPool","infoWithNoBalance","info","ticks","then","result","filter","e","poolKey","index","INVALID","LOADING","_pool","pool","fee","NOT_EXISTS","sqrtRatioX96","liquidity","tickCurrent","EXISTS","Pool","Number","numberToString","error","console","usePool","usePoolV1","getStandard","usePoolIds","call","getPoolIds","useStateCallsData","usePoolList","poolIds","poolIdsLoading","errorNum","fetch","getPoolInfoWithNoBalance","catch","err","push","i","usePosition","positionId","invalid","useCallsData","resultFormat","swapPositionManager","invalidPositions","BigInt","data","positions","increaseLiquidity","identity","params","decreaseLiquidity","mint","tickLower","tickUpper","amount0Desired","amount1Desired","amount0Min","amount1Min","recipient","deadline","useUserTokens","account","useAccount","ownerTokens","useUserV1Tokens","swapPositionManagerV1","useCollectFeesCall","collectInInvalidPosition","collect","usePositionFeesCall","reload","refreshInvalidIncome","refreshIncome","getV2SwapNFTTokenURI","tokenURI","JSON","parse","image","useFourListedPools","swapGraphPool","getAllPools","decreaseInvalidLiquidity","decreaseLiquidityInInvalidPosition","decreaseV1Liquidity","DISABLE_ADD_LIQUIDITY_IDS","useUserV1Positions","tokenIds","setPositions","done","trigger","positionsWithTokenIds","forEach","position","id","String","undefined","useQueryUserPositions","dispatch","useAppDispatch","updateUserPositions","useUserPositions","useAppSelector","state","swapV2Liquidity","userPositions","useMintState","useResetMintState","resetMintState","useMintInfo","baseCurrency","existingPosition","inverted","_currencyBalances$FIE","_currencyBalances$FIE2","_pool$id","independentField","typedValue","leftRangeValue","leftRangeTypedValue","rightRangeValue","rightRangeTypedValue","startPrice","dependentField","FIELD","CURRENCY_A","CURRENCY_B","baseToken","currencies","principal","useAccountPrincipal","tokenABalance","useCurrencyBalance","tokenBBalance","currencyBalances","poolState","noLiquidity","poolLoading","invertPrice","Boolean","price","priceOf","parsedQuoteAmount","tryParseAmount","baseAmount","Price","currency","quotient","invert","invalidPrice","encodeSqrtRatioX96","numerator","denominator","JSBI","greaterThanOrEqual","TickMath","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","priceToClosestTick","currentSqrt","getSqrtRatioAtTick","poolForPosition","tickSpaceLimits","Bound","LOWER","nearestUsableTick","MIN_TICK","TICK_SPACINGS","UPPER","MAX_TICK","tryParseTick","toString","_ticksAtLimit","ticksAtLimit","invalidRange","pricesAtTicks","getTickToPrice","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","Position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","CurrencyAmount","fromRawAmount","parsedAmounts","deposit0Disabled","deposit1Disabled","depositADisabled","depositBDisabled","_parsedAmounts","_parsedAmounts2","BIG_INT_ZERO","fromAmounts","maxAmounts","reduce","accumulator","field","maxAmountSpend","atMaxAmounts","_maxAmounts$field","_parsedAmounts$field","equalTo","errorMessage","_errorMessage","_errorMessage2","_errorMessage3","_errorMessage4","i18n","_","currencyAAmount","currencyBAmount","_currencies$FIELD$CUR","_currencies$FIELD$CUR2","symbol","useMintHandlers","onFieldAInput","value","updateFiled","onFieldBInput","onLeftRangeInput","updateLeftRange","onRightRangeInput","updateRightRange","onStartPriceInput","updateStartPrice","useRangeCallbacks","quoteCurrency","quoteToken","getDecrementLower","tickToPrice","toSignificant","Rounding","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange","updateFullRange","tick","currencyAmount","subtract","transFee","_fraction$length","match","whole","fraction","split","decimals","withoutDecimals","tryParsePrice"],"sourceRoot":""}