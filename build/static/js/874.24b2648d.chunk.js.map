{"version":3,"file":"static/js/874.24b2648d.chunk.js","mappings":"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","sources":["hooks/swap/useIsTickAtLimit.ts","utils/swap/formatCurrencyAmount.ts","utils/swap/formatTickPrice.ts","../packages/swap-sdk/src/utils/maxLiquidityForAmounts.ts","../packages/swap-sdk/src/entities/position.ts","../packages/swap-sdk/src/core/utils/sqrt.ts","../packages/swap-sdk/src/utils/encodeSqrtRatioX96.ts","../packages/swap-sdk/src/utils/nearestUsableTick.ts","../packages/swap-sdk/src/utils/priceTickConversions.ts"],"sourcesContent":["import { nearestUsableTick, TickMath, TICK_SPACINGS, FeeAmount } from \"@w2e/swap-sdk\";\nimport { useMemo } from \"react\";\nimport { Bound } from \"constants/swap\";\n\nexport default function useIsTickAtLimit(\n  feeAmount: FeeAmount | undefined,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n) {\n  return useMemo(\n    () => ({\n      [Bound.LOWER]:\n        feeAmount && tickLower\n          ? tickLower === nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount])\n          : undefined,\n      [Bound.UPPER]:\n        feeAmount && tickUpper\n          ? tickUpper === nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount])\n          : undefined,\n    }),\n    [feeAmount, tickLower, tickUpper],\n  );\n}\n","import { Price, CurrencyAmount, Token, Fraction } from \"@w2e/swap-sdk\";\nimport { JSBI } from \"utils/index\";\nimport { NONE_PRICE_SYMBOL } from \"constants/index\";\n\nexport function formatCurrencyAmount(amount: CurrencyAmount<Token> | undefined, sigFigs: number | undefined | null) {\n  if (!amount) {\n    return NONE_PRICE_SYMBOL;\n  }\n\n  if (JSBI.equal(amount.quotient, JSBI.BigInt(0))) {\n    return \"0\";\n  }\n\n  if (amount.divide(amount.decimalScale).lessThan(new Fraction(1, 100000))) {\n    return \"<0.00001\";\n  }\n\n  return amount.toFixed(sigFigs ? (sigFigs > 8 ? 8 : sigFigs) : 4, { groupSeparator: \",\" });\n}\n\nexport function formatPrice(price: Price<Token, Token> | undefined, sigFigs: number) {\n  if (!price) {\n    return \"-\";\n  }\n\n  if (parseFloat(price.toFixed(sigFigs)) < 0.0001) {\n    return \"<0.0001\";\n  }\n\n  return price.toSignificant(sigFigs);\n}\n","import { Price, Token } from \"@w2e/swap-sdk\";\nimport { formatPrice } from \"./formatCurrencyAmount\";\n\nexport enum Bound {\n  LOWER = \"LOWER\",\n  UPPER = \"UPPER\",\n}\n\nexport function formatTickPrice(\n  price: Price<Token, Token> | undefined,\n  atLimit: { [bound in Bound]?: boolean | undefined },\n  direction: Bound,\n  placeholder?: string,\n) {\n  if (atLimit[direction]) {\n    return direction === Bound.LOWER ? \"0\" : \"∞\";\n  }\n\n  if (!price && placeholder !== undefined) {\n    return placeholder;\n  }\n\n  return formatPrice(price, 5);\n}\n","/* eslint-disable no-param-reassign */\nimport JSBI from \"jsbi\";\nimport { BigintIsh } from \"../core\";\nimport { Q96 } from \"../internalConstants\";\n\n/**\n * Returns an imprecise maximum amount of liquidity received for a given amount of token 0.\n * This function is available to accommodate LiquidityAmounts#getLiquidityForAmount0 in the v3 periphery,\n * which could be more precise by at least 32 bits by dividing by Q64 instead of Q96 in the intermediate step,\n * and shifting the subtracted ratio left by 32 bits. This imprecise calculation will likely be replaced in a future\n * v3 router contract.\n * @param sqrtRatioAX96 The price at the lower boundary\n * @param sqrtRatioBX96 The price at the upper boundary\n * @param amount0 The token0 amount\n * @returns liquidity for amount0, imprecise\n */\nfunction maxLiquidityForAmount0Imprecise(sqrtRatioAX96: JSBI, sqrtRatioBX96: JSBI, amount0: BigintIsh): JSBI {\n  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n    [sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96];\n  }\n  const intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96);\n  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));\n}\n\n/**\n * Returns a precise maximum amount of liquidity received for a given amount of token 0 by dividing by Q64 instead of Q96 in the intermediate step,\n * and shifting the subtracted ratio left by 32 bits.\n * @param sqrtRatioAX96 The price at the lower boundary\n * @param sqrtRatioBX96 The price at the upper boundary\n * @param amount0 The token0 amount\n * @returns liquidity for amount0, precise\n */\nfunction maxLiquidityForAmount0Precise(sqrtRatioAX96: JSBI, sqrtRatioBX96: JSBI, amount0: BigintIsh): JSBI {\n  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n    [sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96];\n  }\n\n  const numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96);\n  const denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));\n\n  return JSBI.divide(numerator, denominator);\n}\n\n/**\n * Computes the maximum amount of liquidity received for a given amount of token1\n * @param sqrtRatioAX96 The price at the lower tick boundary\n * @param sqrtRatioBX96 The price at the upper tick boundary\n * @param amount1 The token1 amount\n * @returns liquidity for amount1\n */\nfunction maxLiquidityForAmount1(sqrtRatioAX96: JSBI, sqrtRatioBX96: JSBI, amount1: BigintIsh): JSBI {\n  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n    [sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96];\n  }\n  return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));\n}\n\n/**\n * Computes the maximum amount of liquidity received for a given amount of token0, token1,\n * and the prices at the tick boundaries.\n * @param sqrtRatioCurrentX96 the current price\n * @param sqrtRatioAX96 price at lower boundary\n * @param sqrtRatioBX96 price at upper boundary\n * @param amount0 token0 amount\n * @param amount1 token1 amount\n * @param useFullPrecision if false, liquidity will be maximized according to what the router can calculate,\n * not what core can theoretically support\n */\nexport function maxLiquidityForAmounts(\n  sqrtRatioCurrentX96: JSBI,\n  sqrtRatioAX96: JSBI,\n  sqrtRatioBX96: JSBI,\n  amount0: BigintIsh,\n  amount1: BigintIsh,\n  useFullPrecision: boolean,\n): JSBI {\n  if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {\n    [sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96];\n  }\n\n  const maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise;\n\n  if (JSBI.lessThanOrEqual(sqrtRatioCurrentX96, sqrtRatioAX96)) {\n    return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n  }\n  if (JSBI.lessThan(sqrtRatioCurrentX96, sqrtRatioBX96)) {\n    const liquidity0 = maxLiquidityForAmount0(sqrtRatioCurrentX96, sqrtRatioBX96, amount0);\n    const liquidity1 = maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioCurrentX96, amount1);\n    return JSBI.lessThan(liquidity0, liquidity1) ? liquidity0 : liquidity1;\n  }\n  return maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n}\n","import JSBI from \"jsbi\";\nimport invariant from \"tiny-invariant\";\nimport { BigintIsh, MaxUint256, Percent, Price, CurrencyAmount, Token } from \"../core\";\nimport { ZERO } from \"../internalConstants\";\nimport { maxLiquidityForAmounts } from \"../utils/maxLiquidityForAmounts\";\nimport { tickToPrice } from \"../utils/priceTickConversions\";\nimport { SqrtPriceMath } from \"../utils/sqrtPriceMath\";\nimport { TickMath } from \"../utils/tickMath\";\nimport { encodeSqrtRatioX96 } from \"../utils/encodeSqrtRatioX96\";\nimport { Pool } from \"./pool\";\n\ninterface PositionConstructorArgs {\n  pool: Pool;\n  tickLower: number;\n  tickUpper: number;\n  liquidity: BigintIsh;\n}\n\n/**\n * Represents a position on a ICPSwap V3 Pool\n */\nexport class Position {\n  public readonly pool: Pool;\n\n  public readonly tickLower: number;\n\n  public readonly tickUpper: number;\n\n  public readonly liquidity: JSBI;\n\n  // cached resuts for the getters\n  private _token0Amount: CurrencyAmount<Token> | null = null;\n\n  private _token1Amount: CurrencyAmount<Token> | null = null;\n\n  private _mintAmounts: Readonly<{ amount0: JSBI; amount1: JSBI }> | null = null;\n\n  /**\n   * Constructs a position for a given pool with the given liquidity\n   * @param pool For which pool the liquidity is assigned\n   * @param liquidity The amount of liquidity that is in the position\n   * @param tickLower The lower tick of the position\n   * @param tickUpper The upper tick of the position\n   */\n  public constructor({ pool, liquidity, tickLower, tickUpper }: PositionConstructorArgs) {\n    invariant(tickLower < tickUpper, \"TICK_ORDER\");\n    invariant(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0, \"TICK_LOWER\");\n    invariant(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0, \"TICK_UPPER\");\n\n    this.pool = pool;\n    this.tickLower = tickLower;\n    this.tickUpper = tickUpper;\n    this.liquidity = JSBI.BigInt(liquidity);\n  }\n\n  /**\n   * Returns the price of token0 at the lower tick\n   */\n  public get token0PriceLower(): Price<Token, Token> {\n    return tickToPrice(this.pool.token0, this.pool.token1, this.tickLower);\n  }\n\n  /**\n   * Returns the price of token0 at the upper tick\n   */\n  public get token0PriceUpper(): Price<Token, Token> {\n    return tickToPrice(this.pool.token0, this.pool.token1, this.tickUpper);\n  }\n\n  /**\n   * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price\n   */\n  public get amount0(): CurrencyAmount<Token> {\n    if (this._token0Amount === null) {\n      if (this.pool.tickCurrent < this.tickLower) {\n        this._token0Amount = CurrencyAmount.fromRawAmount(\n          this.pool.token0,\n          SqrtPriceMath.getAmount0Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            false,\n          ),\n        );\n      } else if (this.pool.tickCurrent < this.tickUpper) {\n        this._token0Amount = CurrencyAmount.fromRawAmount(\n          this.pool.token0,\n          SqrtPriceMath.getAmount0Delta(\n            this.pool.sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            false,\n          ),\n        );\n      } else {\n        this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, ZERO);\n      }\n    }\n    return this._token0Amount;\n  }\n\n  /**\n   * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price\n   */\n  public get amount1(): CurrencyAmount<Token> {\n    if (this._token1Amount === null) {\n      if (this.pool.tickCurrent < this.tickLower) {\n        this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, ZERO);\n      } else if (this.pool.tickCurrent < this.tickUpper) {\n        this._token1Amount = CurrencyAmount.fromRawAmount(\n          this.pool.token1,\n          SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            this.pool.sqrtRatioX96,\n            this.liquidity,\n            false,\n          ),\n        );\n      } else {\n        this._token1Amount = CurrencyAmount.fromRawAmount(\n          this.pool.token1,\n          SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            false,\n          ),\n        );\n      }\n    }\n    return this._token1Amount;\n  }\n\n  /**\n   * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage\n   * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert\n   * @returns The sqrt ratios after slippage\n   */\n  private ratiosAfterSlippage(slippageTolerance: Percent): {\n    sqrtRatioX96Lower: JSBI;\n    sqrtRatioX96Upper: JSBI;\n  } {\n    const priceLower = this.pool.token0Price.asFraction.multiply(new Percent(1).subtract(slippageTolerance));\n    const priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1));\n    let sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator);\n    if (JSBI.lessThanOrEqual(sqrtRatioX96Lower, TickMath.MIN_SQRT_RATIO)) {\n      sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1));\n    }\n    let sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator);\n    if (JSBI.greaterThanOrEqual(sqrtRatioX96Upper, TickMath.MAX_SQRT_RATIO)) {\n      sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1));\n    }\n    return {\n      sqrtRatioX96Lower,\n      sqrtRatioX96Upper,\n    };\n  }\n\n  /**\n   * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position\n   * with the given slippage tolerance\n   * @param slippageTolerance Tolerance of unfavorable slippage from the current price\n   * @returns The amounts, with slippage\n   */\n  public mintAmountsWithSlippage(slippageTolerance: Percent): Readonly<{ amount0: JSBI; amount1: JSBI }> {\n    // get lower/upper prices\n    const { sqrtRatioX96Upper, sqrtRatioX96Lower } = this.ratiosAfterSlippage(slippageTolerance);\n\n    // construct counterfactual pools\n    const poolLower = new Pool(\n      this.pool.id,\n      this.pool.token0,\n      this.pool.token1,\n      this.pool.fee,\n      sqrtRatioX96Lower,\n      0 /* liquidity doesn't matter */,\n      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower),\n    );\n    const poolUpper = new Pool(\n      this.pool.id,\n      this.pool.token0,\n      this.pool.token1,\n      this.pool.fee,\n      sqrtRatioX96Upper,\n      0 /* liquidity doesn't matter */,\n      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper),\n    );\n\n    // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)\n    const positionThatWillBeCreated = Position.fromAmounts({\n      pool: this.pool,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper,\n      ...this.mintAmounts, // the mint amounts are what will be passed as calldata\n      useFullPrecision: false,\n    });\n\n    // we want the smaller amounts...\n    // ...which occurs at the upper price for amount0...\n    const { amount0 } = new Position({\n      pool: poolUpper,\n      liquidity: positionThatWillBeCreated.liquidity,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper,\n    }).mintAmounts;\n    // ...and the lower for amount1\n    const { amount1 } = new Position({\n      pool: poolLower,\n      liquidity: positionThatWillBeCreated.liquidity,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper,\n    }).mintAmounts;\n\n    return { amount0, amount1 };\n  }\n\n  /**\n   * Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the\n   * position with the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the current price\n   * @returns The amounts, with slippage\n   */\n  public burnAmountsWithSlippage(slippageTolerance: Percent): Readonly<{ amount0: JSBI; amount1: JSBI }> {\n    // get lower/upper prices\n    const { sqrtRatioX96Upper, sqrtRatioX96Lower } = this.ratiosAfterSlippage(slippageTolerance);\n\n    // construct counterfactual pools\n    const poolLower = new Pool(\n      this.pool.id,\n      this.pool.token0,\n      this.pool.token1,\n      this.pool.fee,\n      sqrtRatioX96Lower,\n      0 /* liquidity doesn't matter */,\n      TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower),\n    );\n    const poolUpper = new Pool(\n      this.pool.id,\n      this.pool.token0,\n      this.pool.token1,\n      this.pool.fee,\n      sqrtRatioX96Upper,\n      0 /* liquidity doesn't matter */,\n      TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper),\n    );\n\n    // we want the smaller amounts...\n    // ...which occurs at the upper price for amount0...\n    const amount0 = new Position({\n      pool: poolUpper,\n      liquidity: this.liquidity,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper,\n    }).amount0;\n    // ...and the lower for amount1\n    const amount1 = new Position({\n      pool: poolLower,\n      liquidity: this.liquidity,\n      tickLower: this.tickLower,\n      tickUpper: this.tickUpper,\n    }).amount1;\n\n    return { amount0: amount0.quotient, amount1: amount1.quotient };\n  }\n\n  /**\n   * Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at\n   * the current price for the pool\n   */\n  public get mintAmounts(): Readonly<{ amount0: JSBI; amount1: JSBI }> {\n    if (this._mintAmounts === null) {\n      if (this.pool.tickCurrent < this.tickLower) {\n        return {\n          amount0: SqrtPriceMath.getAmount0Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            true,\n          ),\n          amount1: ZERO,\n        };\n      } if (this.pool.tickCurrent < this.tickUpper) {\n        return {\n          amount0: SqrtPriceMath.getAmount0Delta(\n            this.pool.sqrtRatioX96,\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            true,\n          ),\n          amount1: SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            this.pool.sqrtRatioX96,\n            this.liquidity,\n            true,\n          ),\n        };\n      } \n        return {\n          amount0: ZERO,\n          amount1: SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtRatioAtTick(this.tickLower),\n            TickMath.getSqrtRatioAtTick(this.tickUpper),\n            this.liquidity,\n            true,\n          ),\n        };\n      \n    }\n    return this._mintAmounts;\n  }\n\n  /**\n   * Computes the maximum amount of liquidity received for a given amount of token0, token1,\n   * and the prices at the tick boundaries.\n   * @param pool The pool for which the position should be created\n   * @param tickLower The lower tick of the position\n   * @param tickUpper The upper tick of the position\n   * @param amount0 token0 amount\n   * @param amount1 token1 amount\n   * @param useFullPrecision If false, liquidity will be maximized according to what the router can calculate,\n   * not what core can theoretically support\n   * @returns The amount of liquidity for the position\n   */\n  public static fromAmounts({\n    pool,\n    tickLower,\n    tickUpper,\n    amount0,\n    amount1,\n    useFullPrecision,\n  }: {\n    pool: Pool;\n    tickLower: number;\n    tickUpper: number;\n    amount0: BigintIsh;\n    amount1: BigintIsh;\n    useFullPrecision: boolean;\n  }) {\n    const sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n    const sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n    return new Position({\n      pool,\n      tickLower,\n      tickUpper,\n      liquidity: maxLiquidityForAmounts(\n        pool.sqrtRatioX96,\n        sqrtRatioAX96,\n        sqrtRatioBX96,\n        amount0,\n        amount1,\n        useFullPrecision,\n      ),\n    });\n  }\n\n  /**\n   * Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1\n   * @param pool The pool for which the position is created\n   * @param tickLower The lower tick\n   * @param tickUpper The upper tick\n   * @param amount0 The desired amount of token0\n   * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,\n   * not what core can theoretically support\n   * @returns The position\n   */\n  public static fromAmount0({\n    pool,\n    tickLower,\n    tickUpper,\n    amount0,\n    useFullPrecision,\n  }: {\n    pool: Pool;\n    tickLower: number;\n    tickUpper: number;\n    amount0: BigintIsh;\n    useFullPrecision: boolean;\n  }) {\n    return Position.fromAmounts({\n      pool,\n      tickLower,\n      tickUpper,\n      amount0,\n      amount1: MaxUint256,\n      useFullPrecision,\n    });\n  }\n\n  /**\n   * Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0\n   * @param pool The pool for which the position is created\n   * @param tickLower The lower tick\n   * @param tickUpper The upper tick\n   * @param amount1 The desired amount of token1\n   * @returns The position\n   */\n  public static fromAmount1({\n    pool,\n    tickLower,\n    tickUpper,\n    amount1,\n  }: {\n    pool: Pool;\n    tickLower: number;\n    tickUpper: number;\n    amount1: BigintIsh;\n  }) {\n    // this function always uses full precision,\n    return Position.fromAmounts({\n      pool,\n      tickLower,\n      tickUpper,\n      amount0: MaxUint256,\n      amount1,\n      useFullPrecision: true,\n    });\n  }\n}\n","import JSBI from \"jsbi\";\nimport invariant from \"tiny-invariant\";\n\nexport const MAX_SAFE_INTEGER = JSBI.BigInt(Number.MAX_SAFE_INTEGER);\n\nconst ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst TWO = JSBI.BigInt(2);\n\n/**\n * Computes floor(sqrt(value))\n * @param value the value for which to compute the square root, rounded down\n */\nexport function sqrt(value: JSBI): JSBI {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), \"NEGATIVE\");\n\n  // rely on built in sqrt if possible\n  if (JSBI.lessThan(value, MAX_SAFE_INTEGER)) {\n    return JSBI.BigInt(Math.floor(Math.sqrt(JSBI.toNumber(value))));\n  }\n\n  let z: JSBI;\n  let x: JSBI;\n  z = value;\n  x = JSBI.add(JSBI.divide(value, TWO), ONE);\n  while (JSBI.lessThan(x, z)) {\n    z = x;\n    x = JSBI.divide(JSBI.add(JSBI.divide(value, x), x), TWO);\n  }\n  return z;\n}\n","import JSBI from \"jsbi\";\nimport { BigintIsh, sqrt } from \"../core\";\n\n/**\n * Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0\n * @param amount1 The numerator amount i.e., the amount of token1\n * @param amount0 The denominator amount i.e., the amount of token0\n * @returns The sqrt ratio\n */\n\nexport function encodeSqrtRatioX96(\n  amount1: BigintIsh,\n  amount0: BigintIsh\n): JSBI {\n  const numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192));\n  const denominator = JSBI.BigInt(amount0);\n  const ratioX192 = JSBI.divide(numerator, denominator);\n  return sqrt(ratioX192);\n}\n","import invariant from \"tiny-invariant\";\nimport { TickMath } from \"./tickMath\";\n\n/**\n * Returns the closest tick that is nearest a given tick and usable for the given tick spacing\n * @param tick the target tick\n * @param tickSpacing the spacing of the pool\n */\nexport function nearestUsableTick(tick: number, tickSpacing: number) {\n  invariant(Number.isInteger(tick) && Number.isInteger(tickSpacing), \"INTEGERS\");\n  invariant(tickSpacing > 0, \"TICK_SPACING\");\n  invariant(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK, \"TICK_BOUND\");\n  const rounded = Math.round(tick / tickSpacing) * tickSpacing;\n  if (rounded < TickMath.MIN_TICK) return rounded + tickSpacing;\n  if (rounded > TickMath.MAX_TICK) return rounded - tickSpacing;\n  return rounded;\n}\n","import JSBI from \"jsbi\";\nimport { Price, Token } from \"../core\";\nimport { Q192 } from \"../internalConstants\";\nimport { encodeSqrtRatioX96 } from \"./encodeSqrtRatioX96\";\nimport { TickMath } from \"./tickMath\";\n\n/**\n * Returns a price object corresponding to the input tick and the base/quote token\n * Inputs must be tokens because the address order is used to interpret the price represented by the tick\n * @param baseToken the base token of the price\n * @param quoteToken the quote token of the price\n * @param tick the tick for which to return the price\n */\nexport function tickToPrice(baseToken: Token, quoteToken: Token, tick: number): Price<Token, Token> {\n  const sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n  const ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96);\n\n  return baseToken.sortsBefore(quoteToken)\n    ? new Price(baseToken, quoteToken, Q192, ratioX192)\n    : new Price(baseToken, quoteToken, ratioX192, Q192);\n}\n\n/**\n * Returns the first tick for which the given price is greater than or equal to the tick price\n * @param price for which to return the closest tick that represents a price less than or equal to the input price,\n * i.e. the price of the returned tick is less than or equal to the input price\n */\nexport function priceToClosestTick(price: Price<Token, Token>): number {\n  const sorted = price.baseCurrency.sortsBefore(price.quoteCurrency);\n\n  const sqrtRatioX96 = sorted\n    ? encodeSqrtRatioX96(price.numerator, price.denominator)\n    : encodeSqrtRatioX96(price.denominator, price.numerator);\n\n  let tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96);\n  const nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1);\n  if (sorted) {\n    if (!price.lessThan(nextTickPrice)) {\n      tick++;\n    }\n  } else if (!price.greaterThan(nextTickPrice)) {\n    tick++;\n  }\n  return tick;\n}\n"],"names":["useIsTickAtLimit","feeAmount","tickLower","tickUpper","useMemo","Bound","LOWER","nearestUsableTick","TickMath","MIN_TICK","TICK_SPACINGS","undefined","UPPER","MAX_TICK","formatCurrencyAmount","amount","sigFigs","JSBI","equal","quotient","BigInt","divide","decimalScale","lessThan","Fraction","toFixed","groupSeparator","NONE_PRICE_SYMBOL","formatPrice","price","parseFloat","toSignificant","formatTickPrice","atLimit","direction","placeholder","maxLiquidityForAmount0Imprecise","sqrtRatioAX96","sqrtRatioBX96","amount0","intermediate","Q96","maxLiquidityForAmount0Precise","numerator","denominator","maxLiquidityForAmount1","amount1","maxLiquidityForAmounts","sqrtRatioCurrentX96","useFullPrecision","maxLiquidityForAmount0","liquidity0","liquidity1","Position","constructor","_ref","pool","liquidity","_token0Amount","_token1Amount","_mintAmounts","invariant","tickSpacing","this","token0PriceLower","tickToPrice","token0","token1","token0PriceUpper","tickCurrent","CurrencyAmount","fromRawAmount","SqrtPriceMath","getAmount0Delta","getSqrtRatioAtTick","sqrtRatioX96","ZERO","getAmount1Delta","ratiosAfterSlippage","slippageTolerance","priceLower","token0Price","asFraction","multiply","Percent","subtract","priceUpper","add","sqrtRatioX96Lower","encodeSqrtRatioX96","MIN_SQRT_RATIO","sqrtRatioX96Upper","MAX_SQRT_RATIO","mintAmountsWithSlippage","poolLower","Pool","id","fee","getTickAtSqrtRatio","poolUpper","positionThatWillBeCreated","fromAmounts","Object","assign","mintAmounts","burnAmountsWithSlippage","_ref2","fromAmount0","_ref3","MaxUint256","fromAmount1","_ref4","MAX_SAFE_INTEGER","Number","ONE","TWO","value","Math","floor","sqrt","z","x","tick","isInteger","rounded","round","baseToken","quoteToken","ratioX192","sortsBefore","Price","Q192","priceToClosestTick","sorted","baseCurrency","quoteCurrency","nextTickPrice","greaterThan"],"sourceRoot":""}