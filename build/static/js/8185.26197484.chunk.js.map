{"version":3,"file":"static/js/8185.26197484.chunk.js","mappings":"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","sources":["store/swap/liquidity/hooks.ts","utils/swap/getTickToPrice.ts","utils/swap/maxAmountSpend.ts","utils/swap/mint.ts"],"sourcesContent":["import { useCallback, useMemo } from \"react\";\nimport { useAppSelector, useAppDispatch } from \"store/hooks\";\nimport { Bound, BIG_INT_ZERO, FIELD } from \"constants/swap\";\nimport { TOKEN_STANDARD } from \"@w2e/types\";\nimport {\n  Price,\n  CurrencyAmount,\n  Rounding,\n  nearestUsableTick,\n  TickMath,\n  tickToPrice,\n  TICK_SPACINGS,\n  encodeSqrtRatioX96,\n  priceToClosestTick,\n  Pool,\n  Position,\n  Token,\n  FeeAmount,\n} from \"@w2e/swap-sdk\";\nimport { tryParseTick } from \"utils/swap/mint\";\nimport { tryParseAmount, inputNumberCheck } from \"utils/swap\";\nimport { getTickToPrice } from \"utils/swap/getTickToPrice\";\nimport { usePool, PoolState, useTokensHasPairWithBaseToken } from \"hooks/swap/usePools\";\nimport { JSBI } from \"utils/index\";\nimport { useCurrencyBalance } from \"hooks/token/useTokenBalance\";\nimport { maxAmountSpend } from \"utils/swap/maxAmountSpend\";\nimport { t } from \"@lingui/macro\";\nimport { useAccountPrincipal } from \"store/auth/hooks\";\nimport { useSwapPoolAvailable } from \"hooks/swap/v3Calls\";\nimport { getTokenStandard } from \"store/token/cache/hooks\";\nimport {\n  updateFiled,\n  updateLeftRange,\n  updateRightRange,\n  updateStartPrice,\n  updateFullRange,\n  resetMintState,\n} from \"./actions\";\n\nexport function useMintState() {\n  return useAppSelector((state) => state.swapLiquidity);\n}\n\nexport function useResetMintState() {\n  const dispatch = useAppDispatch();\n  return useCallback(() => {\n    dispatch(resetMintState());\n  }, [dispatch]);\n}\n\nconst VALID_TOKEN_STANDARDS_CREATE_POOL: any[] = [TOKEN_STANDARD.ICRC1, TOKEN_STANDARD.ICRC2];\n\nexport function useMintInfo(\n  currencyA: Token | undefined,\n  currencyB: Token | undefined,\n  feeAmount: FeeAmount | undefined,\n  baseCurrency: Token | undefined,\n  existingPosition?: Position,\n  inverted?: boolean | undefined,\n) {\n  const principal = useAccountPrincipal();\n  const {\n    independentField,\n    typedValue,\n    leftRangeValue: leftRangeTypedValue,\n    rightRangeValue: rightRangeTypedValue,\n    startPrice,\n  } = useMintState();\n\n  const dependentField = independentField === FIELD.CURRENCY_A ? FIELD.CURRENCY_B : FIELD.CURRENCY_A;\n\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency],\n  );\n\n  const currencies = useMemo(\n    () => ({\n      [FIELD.CURRENCY_A]: currencyA,\n      [FIELD.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB],\n  );\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB],\n  );\n\n  const tokens = useMemo(() => (tokenA && tokenB ? [tokenA.address, tokenB.address] : undefined), [tokenA, tokenB]);\n\n  const hasPairWithBaseToken = useTokensHasPairWithBaseToken(tokens);\n\n  const { result: tokenABalance } = useCurrencyBalance(principal, tokenA);\n  const { result: tokenBBalance } = useCurrencyBalance(principal, tokenB);\n\n  const currencyBalances = {\n    [FIELD.CURRENCY_A]: tokenABalance,\n    [FIELD.CURRENCY_B]: tokenBBalance,\n  };\n\n  const [poolState, pool] = usePool(currencyA, currencyB, feeAmount);\n\n  const noLiquidity = poolState === PoolState.NOT_EXISTS;\n  const poolLoading = poolState === PoolState.LOADING;\n\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0));\n\n  const available = useSwapPoolAvailable(pool?.id);\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseAmount(startPrice || \"0.1\", invertPrice ? token0 : token1);\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseAmount(\"1\", invertPrice ? token1 : token0);\n\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient,\n              )\n            : undefined;\n\n        return (invertPrice ? price?.invert() : price) ?? undefined;\n      }\n      return undefined;\n    }\n    return pool && token0 ? pool.priceOf(token0) : undefined;\n  }, [noLiquidity, startPrice, invertPrice, token1, token0, pool]);\n\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined;\n    const invalid =\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      );\n    return invalid;\n  }, [price]);\n\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price);\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick);\n\n      return new Pool(\"\", tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, []);\n    }\n\n    return undefined;\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB]);\n\n  const poolForPosition = pool ?? mockPool;\n\n  const tickSpaceLimits = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount],\n  );\n\n  const ticks = useMemo(() => {\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === \"number\"\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === \"boolean\") ||\n            (!invertPrice && typeof leftRangeTypedValue === \"boolean\") ||\n            // if no liquidity, full range by default\n            (noLiquidity &&\n              ((invertPrice && rightRangeTypedValue === \"\") || (!invertPrice && leftRangeTypedValue === \"\")))\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === \"number\"\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === \"boolean\") ||\n            (invertPrice && typeof leftRangeTypedValue === \"boolean\") ||\n            // if no liquidity, full range by default\n            (noLiquidity &&\n              ((!invertPrice && rightRangeTypedValue === \"\") || (invertPrice && leftRangeTypedValue === \"\")))\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    };\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n    noLiquidity,\n  ]);\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {};\n\n  const _ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount],\n  );\n\n  const ticksAtLimit = useMemo(() => {\n    if (!inverted) return _ticksAtLimit;\n\n    return {\n      [Bound.LOWER]: _ticksAtLimit[Bound.UPPER] ? true : undefined,\n      [Bound.UPPER]: _ticksAtLimit[Bound.LOWER] ? true : undefined,\n    };\n  }, [_ticksAtLimit, inverted]);\n\n  const invalidRange = Boolean(\n    typeof tickLower === \"number\" && typeof tickUpper === \"number\" && tickLower >= tickUpper,\n  );\n\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    };\n  }, [token0, token1, ticks]);\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks;\n\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice)),\n  );\n\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n\n  const dependentAmount = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped;\n    const dependentCurrency = dependentField === FIELD.CURRENCY_B ? currencyB : currencyA;\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === \"number\" &&\n      typeof tickUpper === \"number\" &&\n      poolForPosition\n    ) {\n      if (outOfRange || invalidRange) {\n        return undefined;\n      }\n\n      const position = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true,\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          });\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0;\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient);\n    }\n\n    return undefined;\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ]);\n\n  const parsedAmounts = useMemo(() => {\n    return {\n      [FIELD.CURRENCY_A]: independentField === FIELD.CURRENCY_A ? independentAmount : dependentAmount,\n      [FIELD.CURRENCY_B]: independentField === FIELD.CURRENCY_A ? dependentAmount : independentAmount,\n    };\n  }, [dependentAmount, independentAmount, independentField]);\n\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === \"number\" && poolForPosition && poolForPosition.tickCurrent >= tickUpper,\n  );\n\n  const deposit1Disabled = Boolean(\n    typeof tickLower === \"number\" && poolForPosition && poolForPosition.tickCurrent <= tickLower,\n  );\n\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA)),\n    );\n\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB)),\n    );\n\n  const position = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== \"number\" ||\n      typeof tickUpper !== \"number\" ||\n      invalidRange\n    ) {\n      return undefined;\n    }\n\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? FIELD.CURRENCY_A : FIELD.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO;\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? FIELD.CURRENCY_B : FIELD.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO;\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true,\n      });\n    }\n\n    return undefined;\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ]);\n\n  const maxAmounts: { [field in FIELD]?: CurrencyAmount<Token> } = [FIELD.CURRENCY_A, FIELD.CURRENCY_B].reduce(\n    (accumulator, field) => {\n      return {\n        ...accumulator,\n        [field]: maxAmountSpend(currencyBalances[field]),\n      };\n    },\n    {},\n  );\n\n  const atMaxAmounts: { [field in FIELD]?: CurrencyAmount<Token> } = [FIELD.CURRENCY_A, FIELD.CURRENCY_B].reduce(\n    (accumulator, field) => {\n      return {\n        ...accumulator,\n        [field]: maxAmounts[field]?.equalTo(parsedAmounts[field] ?? \"0\"),\n      };\n    },\n    {},\n  );\n\n  let errorMessage: string | undefined;\n\n  if (hasPairWithBaseToken !== true) errorMessage = errorMessage ?? t`No pair with icp`;\n\n  if (inputNumberCheck(typedValue) === false) errorMessage = errorMessage ?? t`Amount exceeds limit`;\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? t`Invalid pair`;\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? t`Invalid price input`;\n  }\n\n  if (invalidRange) {\n    errorMessage = errorMessage ?? t`Invalid Range`;\n  }\n\n  if (\n    (!parsedAmounts[FIELD.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[FIELD.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? t`Enter an amount`;\n  }\n\n  if (typeof available === \"boolean\" && !available) {\n    errorMessage = errorMessage ?? t`This pool is not available now`;\n  }\n\n  if (poolState === PoolState.NOT_CHECK) {\n    errorMessage = errorMessage ?? t`Waiting for verify the pool...`;\n  }\n\n  const { [FIELD.CURRENCY_A]: currencyAAmount, [FIELD.CURRENCY_B]: currencyBAmount } = parsedAmounts;\n\n  if (\n    currencyA &&\n    currencyAAmount &&\n    currencyBalances?.[FIELD.CURRENCY_A]?.lessThan(\n      currencyAAmount.add(CurrencyAmount.fromRawAmount(currencyA.wrapped, currencyA.transFee)),\n    )\n  ) {\n    errorMessage = errorMessage ?? `Insufficient ${currencyA?.symbol} balance`;\n  }\n\n  if (\n    currencyB &&\n    currencyBAmount &&\n    currencyBalances?.[FIELD.CURRENCY_B]?.lessThan(\n      currencyBAmount.add(CurrencyAmount.fromRawAmount(currencyB.wrapped, currencyB.transFee)),\n    )\n  ) {\n    errorMessage = errorMessage ?? `Insufficient ${currencyB?.symbol} balance`;\n  }\n\n  if (\n    currencyA &&\n    currencyAAmount &&\n    !depositADisabled &&\n    !currencyAAmount.greaterThan(CurrencyAmount.fromRawAmount(currencyA.wrapped, currencyA.transFee))\n  ) {\n    errorMessage = errorMessage ?? t`${currencyA?.symbol} amount must greater than trans fee`;\n  }\n\n  if (\n    currencyB &&\n    currencyBAmount &&\n    !depositBDisabled &&\n    !currencyBAmount.greaterThan(CurrencyAmount.fromRawAmount(currencyB.wrapped, currencyB.transFee))\n  ) {\n    errorMessage = errorMessage ?? t`${currencyB?.symbol} amount must greater than trans fee`;\n  }\n\n  if (\n    (!VALID_TOKEN_STANDARDS_CREATE_POOL.includes(getTokenStandard(currencyB?.address)) ||\n      !VALID_TOKEN_STANDARDS_CREATE_POOL.includes(getTokenStandard(currencyA?.address))) &&\n    noLiquidity\n  ) {\n    errorMessage = errorMessage ?? t`Only ICRC1 and ICRC2 support`;\n  }\n\n  return {\n    ticks,\n    pricesAtTicks,\n    invalidRange,\n    outOfRange,\n    invalidPrice,\n    parsedAmounts,\n    dependentField,\n    depositADisabled,\n    depositBDisabled,\n    ticksAtLimit,\n    errorMessage,\n    position,\n    price,\n    invertPrice,\n    pool,\n    noLiquidity,\n    currencyBalances,\n    atMaxAmounts,\n    maxAmounts,\n    poolLoading,\n  };\n}\n\nexport function useMintHandlers() {\n  const dispatch = useAppDispatch();\n\n  const onFieldAInput = (value: string) => {\n    dispatch(\n      updateFiled({\n        field: FIELD.CURRENCY_A,\n        typedValue: value,\n      }),\n    );\n  };\n\n  const onFieldBInput = (value: string) => {\n    dispatch(\n      updateFiled({\n        field: FIELD.CURRENCY_B,\n        typedValue: value,\n      }),\n    );\n  };\n\n  const onLeftRangeInput = (value: string) => {\n    dispatch(updateLeftRange(value));\n  };\n\n  const onRightRangeInput = (value: string) => {\n    dispatch(updateRightRange(value));\n  };\n\n  const onStartPriceInput = (value: string) => {\n    dispatch(updateStartPrice(value));\n  };\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  };\n}\n\nexport function useRangeCallbacks(\n  baseCurrency: Token | undefined,\n  quoteCurrency: Token | undefined,\n  feeAmount: FeeAmount,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool: Pool | undefined | null,\n) {\n  const dispatch = useAppDispatch();\n\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency]);\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency]);\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool]);\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === \"number\" && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === \"number\") && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount]);\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP);\n    }\n    return \"\";\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool]);\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(updateFullRange());\n  }, [dispatch]);\n\n  return {\n    getDecrementLower,\n    getIncrementLower,\n    getDecrementUpper,\n    getIncrementUpper,\n    getSetFullRange,\n  };\n}\n","import { Token, Price, tickToPrice } from \"@w2e/swap-sdk\";\n\nexport function getTickToPrice(baseToken?: Token, quoteToken?: Token, tick?: number): Price<Token, Token> | undefined {\n  if (!baseToken || !quoteToken || typeof tick !== \"number\") return undefined;\n  return tickToPrice(baseToken, quoteToken, tick);\n}\n","import { Token, CurrencyAmount } from \"@w2e/swap-sdk\";\n\n/**\n * Given some token amount, return the max that can be spent of it\n * @param currencyAmount to return max of\n */\nexport function maxAmountSpend(currencyAmount?: CurrencyAmount<Token>): CurrencyAmount<Token> | undefined {\n  if (!currencyAmount) return undefined;\n\n  const maxAmountSubFee = currencyAmount.subtract(\n    CurrencyAmount.fromRawAmount(currencyAmount.currency, currencyAmount.currency.transFee * 2),\n  );\n\n  return maxAmountSubFee;\n}\n","import {\n  Price,\n  Token,\n  priceToClosestTick,\n  nearestUsableTick,\n  FeeAmount,\n  TICK_SPACINGS,\n  encodeSqrtRatioX96,\n  TickMath,\n} from \"@w2e/swap-sdk\";\nimport JSBI from \"jsbi\";\n\nexport function tryParsePrice(baseToken?: Token, quoteToken?: Token, value?: string) {\n  if (!baseToken || !quoteToken || !value) {\n    return undefined;\n  }\n\n  if (!value.match(/^\\d*\\.?\\d+$/)) {\n    return undefined;\n  }\n\n  const [whole, fraction] = value.split(\".\");\n\n  const decimals = fraction?.length ?? 0;\n  const withoutDecimals = JSBI.BigInt((whole ?? \"\") + (fraction ?? \"\"));\n\n  return new Price(\n    baseToken,\n    quoteToken,\n    JSBI.multiply(JSBI.BigInt(10 ** decimals), JSBI.BigInt(10 ** baseToken.decimals)),\n    JSBI.multiply(withoutDecimals, JSBI.BigInt(10 ** quoteToken.decimals)),\n  );\n}\n\nexport function tryParseTick(\n  baseToken?: Token,\n  quoteToken?: Token,\n  feeAmount?: FeeAmount,\n  value?: string,\n): number | undefined {\n  if (!baseToken || !quoteToken || !feeAmount || !value) {\n    return undefined;\n  }\n\n  const price = tryParsePrice(baseToken, quoteToken, value);\n\n  if (!price) {\n    return undefined;\n  }\n\n  let tick: number;\n\n  // check price is within min/max bounds, if outside return min/max\n  const sqrtRatioX96 = encodeSqrtRatioX96(price.numerator, price.denominator);\n\n  if (JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) {\n    tick = TickMath.MAX_TICK;\n  } else if (JSBI.lessThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO)) {\n    tick = TickMath.MIN_TICK;\n  } else {\n    // this function is agnostic to the base, will always return the correct tick\n    tick = priceToClosestTick(price);\n  }\n\n  return nearestUsableTick(tick, TICK_SPACINGS[feeAmount]);\n}\n"],"names":["useMintState","useAppSelector","state","swapLiquidity","useResetMintState","dispatch","useAppDispatch","useCallback","resetMintState","VALID_TOKEN_STANDARDS_CREATE_POOL","TOKEN_STANDARD","ICRC1","ICRC2","useMintInfo","currencyA","currencyB","feeAmount","baseCurrency","existingPosition","inverted","_errorMessage","_errorMessage2","_currencyBalances$FIE","_currencyBalances$FIE2","principal","useAccountPrincipal","independentField","typedValue","leftRangeValue","leftRangeTypedValue","rightRangeValue","rightRangeTypedValue","startPrice","dependentField","FIELD","CURRENCY_A","CURRENCY_B","tokenA","tokenB","baseToken","useMemo","wrapped","currencies","token0","token1","sortsBefore","undefined","tokens","address","hasPairWithBaseToken","useTokensHasPairWithBaseToken","result","tokenABalance","useCurrencyBalance","tokenBBalance","currencyBalances","poolState","pool","usePool","noLiquidity","PoolState","NOT_EXISTS","poolLoading","LOADING","invertPrice","Boolean","equals","available","useSwapPoolAvailable","id","price","priceOf","parsedQuoteAmount","tryParseAmount","_ref","baseAmount","Price","currency","quotient","invert","invalidPrice","sqrtRatioX96","encodeSqrtRatioX96","numerator","denominator","JSBI","greaterThanOrEqual","TickMath","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","priceToClosestTick","currentSqrt","getSqrtRatioAtTick","Pool","BigInt","poolForPosition","tickSpaceLimits","Bound","LOWER","nearestUsableTick","MIN_TICK","TICK_SPACINGS","UPPER","MAX_TICK","ticks","tickLower","tryParseTick","toString","tickUpper","_ticksAtLimit","ticksAtLimit","invalidRange","pricesAtTicks","getTickToPrice","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","position","Position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","CurrencyAmount","fromRawAmount","parsedAmounts","deposit0Disabled","tickCurrent","deposit1Disabled","depositADisabled","depositBDisabled","_parsedAmounts","_parsedAmounts2","BIG_INT_ZERO","fromAmounts","maxAmounts","reduce","accumulator","field","maxAmountSpend","atMaxAmounts","_maxAmounts$field","_parsedAmounts$field","equalTo","errorMessage","_errorMessage3","_errorMessage4","_errorMessage5","_errorMessage6","_errorMessage7","_errorMessage8","i18n","_","inputNumberCheck","INVALID","NOT_CHECK","currencyAAmount","currencyBAmount","_errorMessage9","_errorMessage10","_errorMessage11","_errorMessage12","_errorMessage13","add","transFee","concat","symbol","values","0","includes","getTokenStandard","useMintHandlers","onFieldAInput","value","updateFiled","onFieldBInput","onLeftRangeInput","updateLeftRange","onRightRangeInput","updateRightRange","onStartPriceInput","updateStartPrice","useRangeCallbacks","quoteCurrency","quoteToken","getDecrementLower","tickToPrice","toSignificant","Rounding","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange","updateFullRange","tick","currencyAmount","subtract","_fraction$length","match","whole","fraction","split","decimals","length","withoutDecimals","tryParsePrice"],"sourceRoot":""}